{
    "_id": "framebus",
    "_rev": "26-221cf63059e3e05dd39c12ce0e135c95",
    "name": "framebus",
    "description": "Framebus allows you to easily send messages across frames (and iframes) with a simple bus.",
    "dist-tags": {
        "latest": "5.1.2",
        "v5-beta": "5.0.0-rc.1"
    },
    "versions": {
        "5.0.0-rc.1": {
            "name": "framebus",
            "description": "Framebus allows you to easily send messages across frames (and iframes) with a simple bus.",
            "repository": {
                "type": "git",
                "url": "git+ssh://git@github.com/braintree/framebus.git"
            },
            "homepage": "https://github.com/braintree/framebus",
            "version": "5.0.0-rc.1",
            "main": "dist/index.js",
            "scripts": {
                "prepublishOnly": "npm run build",
                "prebuild": "prettier --write .",
                "build": "tsc --declaration",
                "lint": "eslint --ext js,ts .",
                "pretest": "npm run lint",
                "test:unit": "jest spec/unit/",
                "pretest:functional": "gulp functional:prep",
                "test:functional": "wdio wdio.conf.js",
                "test": "npm run test:unit && npm run test:functional",
                "start": "./bin/www"
            },
            "license": "MIT",
            "author": {
                "name": "braintree",
                "email": "code@getbraintree.com"
            },
            "dependencies": {
                "@braintree/uuid": "^0.1.0"
            },
            "devDependencies": {
                "@types/jest": "^26.0.14",
                "@wdio/cli": "^6.5.2",
                "@wdio/local-runner": "^6.5.2",
                "@wdio/mocha-framework": "^6.5.0",
                "@wdio/spec-reporter": "^6.4.7",
                "@wdio/sync": "^6.5.0",
                "async": "^3.2.0",
                "browserify": "^16.5.2",
                "chromedriver": "^85.0.1",
                "del": "^6.0.0",
                "ejs": "^3.1.5",
                "eslint": "^7.10.0",
                "eslint-config-braintree": "5.0.0-typescript-prep-rc.19",
                "express": "^4.10.4",
                "gulp": "^4.0.2",
                "gulp-concat": "^2.4.2",
                "gulp-remove-code": "^3.0.4",
                "gulp-size": "^3.0.0",
                "gulp-streamify": "^1.0.2",
                "gulp-uglify": "^3.0.2",
                "jest": "^26.4.2",
                "morgan": "^1.10.0",
                "prettier": "^2.1.2",
                "ts-jest": "^26.4.1",
                "tsify": "^5.0.2",
                "typescript": "^4.0.3",
                "vinyl-buffer": "^1.0.1",
                "vinyl-source-stream": "^2.0.0",
                "wdio-chromedriver-service": "^6.0.4"
            },
            "jest": {
                "preset": "ts-jest",
                "restoreMocks": true,
                "resetMocks": true
            },
            "readme": "# Framebus [![Build Status](https://travis-ci.org/braintree/framebus.svg)](https://travis-ci.org/braintree/framebus) [![npm version](https://badge.fury.io/js/framebus.svg)](http://badge.fury.io/js/framebus)\n\nFramebus allows you to easily send messages across frames (and iframes) with a simple bus.\n\nIn one frame:\n\n```js\nvar Framebus = require(\"framebus\");\nvar bus = new Framebus();\n\nbus.emit(\"message\", {\n  from: \"Ron\",\n  contents: \"they named it...San Diago\",\n});\n```\n\nIn another frame:\n\n```js\nvar Framebus = require(\"framebus\");\nvar bus = new Framebus();\n\nbus.on(\"message\", function (data) {\n  console.log(data.from + \" said: \" + data.contents);\n});\n```\n\nThe Framebus class takes a configuration object, where all the params are optional.\n\n```js\ntype FramebusOptions = {\n  origin?: string, // default: \"*\"\n  channel?: string, // no default\n  verifyDomain?: (url: string) => boolean, // no default\n};\n```\n\nThe `origin` sets the framebus instance to only operate on the chosen origin.\n\nThe `channel` namespaces the events called with `on` and `emit` so you can have multiple bus instances on the page and have them only communicate with busses with the same channel value.\n\nIf a `verifyDomain` is passed, then the `on` listener will only fire if the domain of the origin of the post message matches the `location.href` value of page or the function passed for `verifyDomain` returns `true`.\n\n```js\nvar bus = new Framebus({\n  verifyDomain: function (url) {\n    // only return true if the domain of the url matches exactly\n    url.indexOf(\"https://my-domain\") === 0;\n  },\n});\n```\n\n## API\n\n#### `target(options: FramebusOptions): framebus`\n\n**returns**: a chainable instance of framebus that operates on the chosen origin.\n\nThis method is used in conjuction with `emit`, `on`, and `off` to restrict their results to the given origin. By default, an origin of `'*'` is used.\n\n```javascript\nframebus\n  .target({\n    origin: \"https://example.com\",\n  })\n  .on(\"my cool event\", function () {});\n// will ignore all incoming 'my cool event' NOT from 'https://example.com'\n```\n\n| Argument  | Type            | Description                        |\n| --------- | --------------- | ---------------------------------- |\n| `options` | FramebusOptions | See above section for more details |\n\n#### `emit('event', data? , callback?): boolean`\n\n**returns**: `true` if the event was successfully published, `false` otherwise\n\n| Argument         | Type     | Description                                          |\n| ---------------- | -------- | ---------------------------------------------------- |\n| `event`          | String   | The name of the event                                |\n| `data`           | Object   | The data to give to subscribers                      |\n| `callback(data)` | Function | Give subscribers a function for easy, direct replies |\n\n#### `on('event', fn): boolean`\n\n**returns**: `true` if the subscriber was successfully added, `false` otherwise\n\nUnless already bound to a scope, the listener will be executed with `this` set\nto the `MessageEvent` received over postMessage.\n\n| Argument               | Type     | Description                                                 |\n| ---------------------- | -------- | ----------------------------------------------------------- |\n| `event`                | String   | The name of the event                                       |\n| `fn(data?, callback?)` | Function | Event handler. Arguments are from the `emit` invocation     |\n| â†³ `this`               | scope    | The `MessageEvent` object from the underlying `postMessage` |\n\n#### `off('event', fn): boolean`\n\n**returns**: `true` if the subscriber was successfully removed, `false` otherwise\n\n| Argument | Type     | Description                      |\n| -------- | -------- | -------------------------------- |\n| `event`  | String   | The name of the event            |\n| `fn`     | Function | The function that was subscribed |\n\n#### `include(popup): boolean`\n\n**returns**: `true` if the popup was successfully included, `false` otherwise\n\n```javascript\nvar popup = window.open(\"https://example.com\");\n\nframebus.include(popup);\nframebus.emit(\"hello popup and friends!\");\n```\n\n| Argument | Type   | Description                                  |\n| -------- | ------ | -------------------------------------------- |\n| `popup`  | Window | The popup refrence returned by `window.open` |\n\n#### `teardown(): void`\n\nCalls `off` on all listeners used for this bus instance and makes subsequent calls to all methods `noop`.\n\n```javascript\nbus.on(\"event-name\", handler);\n\n// event-name listener is torn down\nbus.teardown();\n\n// these now do nothing\nbus.on(\"event-name\", handler);\nbus.emit(\"event-name\", data);\nbus.off(\"event-name\", handler);\n```\n\n## Pitfalls\n\nThese are some things to keep in mind while using **framebus** to handle your\nevent delegation\n\n### Cross-site scripting (XSS)\n\n**framebus** allows convenient event delegation across iframe borders. By\ndefault it will broadcast events to all iframes on the page, regardless of\norigin. Use the optional `target()` method when you know the exact domain of\nthe iframes you are communicating with. This will protect your event data from\nmalicious domains.\n\n### Data is serialized as JSON\n\n**framebus** operates over `postMessage` using `JSON.parse` and `JSON.stringify`\nto facilitate message data passing. Keep in mind that not all JavaScript objects\nserialize cleanly into and out of JSON, such as `undefined`.\n\n### Asynchronicity\n\nEven when the subscriber and publisher are within the same frame, events go\nthrough `postMessage`. Keep in mind that `postMessage` is an asynchronous\nprotocol and that publication and subscription handling occur on separate\niterations of the [event\nloop (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/EventLoop#Event_loop).\n\n### Published callback functions are an abstraction\n\nWhen you specify a `callback` while using `emit`, the function is not actually\ngiven to the subscriber. The subscriber receives a one-time-use function that is\ngenerated locally by the subscriber's **framebus**. This one-time-use callback function\nis pre-configured to publish an event back to the event origin's domain using a\n[UUID](http://tools.ietf.org/html/rfc4122) as the event name. The events occur\nas follows:\n\n1. `http://emitter.example.com` publishes an event with a function as the event data\n\n   ```javascript\n   var callback = function (data) {\n     console.log(\"Got back %s as a reply!\", data);\n   };\n\n   framebus.emit(\"Marco!\", callback, \"http://listener.example.com\");\n   ```\n\n1. The **framebus** on `http://emitter.example.com` generates a UUID as an event name\n   and adds the `callback` as a subscriber to this event.\n1. The **framebus** on `http://listener.example.com` sees that a special callback\n   event is in the event payload. A one-time-use function is created locally and\n   given to subscribers of `'Marco!'` as the event data.\n1. The subscriber on `http://listener.example.com` uses the local one-time-use\n   callback function to send data back to the emitter's origin\n\n   ```javascript\n   framebus\n     .target(\"http://emitter.example.com\")\n     .on(\"Marco!\", function (callback) {\n       callback(\"Polo!\");\n     });\n   ```\n\n1. The one-time-use function on `http://listener.example.com` publishes an event\n   as the UUID generated in **step 2** to the origin that emitted the event.\n1. Back on `http://emitter.example.com`, the `callback` is called and\n   unsubscribed from the special UUID event afterward.\n\n## Development and contributing\n\nSee [**CONTRIBUTING.md**](CONTRIBUTING.md)\n",
            "readmeFilename": "README.md",
            "gitHead": "a0e3564f20ecf2e404bc275d6e720ffff59eb3a1",
            "bugs": {
                "url": "https://github.com/braintree/framebus/issues"
            },
            "_id": "framebus@5.0.0-rc.1",
            "_nodeVersion": "12.14.0",
            "_npmVersion": "6.13.4",
            "dist": {
                "integrity": "sha512-/iKlZY5VLXm2rt8rueLX+9J5Q9d1qyw2rQzilEhcQ7DzK2nk5xWeV8QR9CGFB+th4+4ikH5qXyq1EYVvCLXsUQ==",
                "shasum": "57f431c5694c557175cd5e2a91c36095e25d7008",
                "tarball": "https://registry.npmjs.org/framebus/-/framebus-5.0.0-rc.1.tgz",
                "fileCount": 34,
                "unpackedSize": 31788,
                "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfnMdhCRA9TVsSAnZWagAAht8P/Ro2OrA5mldUhvvNhkQv\naEV1RdGbyU0jMvZ5/mbyeX9jSszBFgqK5Maq386dctnP7xG2wuG9deYq9hZX\nfIG0ls0okoixCX09JVdpYBctosJfg1192XkrBUc/sPMKi9Ubsn096YNpsgMZ\ntTjqNQQ+fXxETHoXUz8MkbKVfVMTiy1MocMpTmJszveO1Zc+YFvf9zIxt3P5\ngbtiDWfpdrv9vMuLnXWFJkvQphikqgmeyrEmYQQZP6mO/4JvPS5iVJreP3/a\npWimsAT6zJKY3HRbsGLsRkABdq7F5z3Spbq/CHiUDbuZC61xeWG5iMWmzEKe\nb5myEkyKWE4UXxqIhj9eCUcKnJ0OAuAtKAf1B0XaIZUUfE4cSLXXgLN/iFNi\nneuPs1h+xDumnfaem49Wpkb2FulJTWHdSHIUZ4L12SYOaOqRaUIkjYdfDPdd\nCcdn5IGp+hl/qEGM8AP/UCWBoiLcxlubrRZJC4sqiRgBDBPGXri7xFEFraTp\nG+rJXR38e1rWNnsWwusv68KRgvhMCtN0re0JkO33xXgpDcAwZyzJvBa2s0Qn\nXxJGS66PzuWVSXtef6cWVqZVPHfwNXNJeClT+DP64iSUaq/cnZWYeSXfQgiz\nsHl2pHY10suO/Jo0ncHPrnXU3Vbp8+yD9V5+prkxKHeopXpFkYdggiC33OKH\n/1Sk\r\n=N2dO\r\n-----END PGP SIGNATURE-----\r\n"
            },
            "maintainers": [
                {
                    "name": "braintree",
                    "email": "team-sdk@getbraintree.com"
                }
            ],
            "_npmUser": {
                "name": "braintree",
                "email": "team-sdk@getbraintree.com"
            },
            "directories": {},
            "_npmOperationalInternal": {
                "host": "s3://npm-registry-packages",
                "tmp": "tmp/framebus_5.0.0-rc.1_1604110176919_0.06913653653159857"
            },
            "_hasShrinkwrap": false
        },
        "5.1.2": {
            "name": "framebus",
            "description": "Framebus allows you to easily send messages across frames (and iframes) with a simple bus.",
            "repository": {
                "type": "git",
                "url": "git+ssh://git@github.com/braintree/framebus.git"
            },
            "homepage": "https://github.com/braintree/framebus",
            "version": "5.1.2",
            "main": "dist/index.js",
            "scripts": {
                "prepublishOnly": "npm run build",
                "prebuild": "prettier --write .",
                "build": "tsc --declaration",
                "lint": "eslint --ext js,ts .",
                "pretest": "npm run lint",
                "test:unit": "jest spec/unit/",
                "pretest:functional": "gulp functional:prep",
                "test:functional": "wdio wdio.conf.js",
                "test": "npm run test:unit && npm run test:functional",
                "prestart": "npm run pretest:functional",
                "start": "./bin/www"
            },
            "license": "MIT",
            "author": {
                "name": "braintree",
                "email": "code@getbraintree.com"
            },
            "dependencies": {
                "@braintree/uuid": "^0.1.0"
            },
            "devDependencies": {
                "@types/jest": "^26.0.19",
                "@wdio/cli": "^6.11.3",
                "@wdio/local-runner": "^6.11.3",
                "@wdio/mocha-framework": "^6.11.0",
                "@wdio/spec-reporter": "^6.11.0",
                "@wdio/sync": "^6.11.0",
                "async": "^3.2.0",
                "browserify": "^17.0.0",
                "chromedriver": "^87.0.5",
                "del": "^6.0.0",
                "ejs": "^3.1.5",
                "eslint": "^7.17.0",
                "eslint-config-braintree": "5.0.0-typescript-prep-rc.19",
                "express": "^4.10.4",
                "gulp": "^4.0.2",
                "gulp-concat": "^2.4.2",
                "gulp-remove-code": "^3.0.4",
                "gulp-size": "^3.0.0",
                "gulp-streamify": "^1.0.2",
                "gulp-uglify": "^3.0.2",
                "jest": "^26.6.3",
                "morgan": "^1.10.0",
                "prettier": "^2.2.1",
                "ts-jest": "^26.4.4",
                "tsify": "^5.0.2",
                "typescript": "^4.1.3",
                "vinyl-buffer": "^1.0.1",
                "vinyl-source-stream": "^2.0.0",
                "wdio-chromedriver-service": "^6.0.4"
            },
            "jest": {
                "preset": "ts-jest",
                "restoreMocks": true,
                "resetMocks": true
            },
            "gitHead": "454d1fe3ed001941e314fad21faac6e86d804774",
            "bugs": {
                "url": "https://github.com/braintree/framebus/issues"
            },
            "_id": "framebus@5.1.2",
            "_nodeVersion": "14.15.4",
            "_npmVersion": "6.14.10",
            "dist": {
                "integrity": "sha512-Z/y6/0gHVx4Td4c0jkDiASBo0pXlJ2fKOP6CynSFnxTzqojG9xOKOFOqoYkcBHlz1vP4t4yHHR6Esp+GsYIh/Q==",
                "shasum": "cb38cf6a282d405411227cfaab4a1095ca9e8e15",
                "tarball": "https://registry.npmjs.org/framebus/-/framebus-5.1.2.tgz",
                "fileCount": 34,
                "unpackedSize": 34180,
                "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgLTfiCRA9TVsSAnZWagAA+LIP/2vsNZ1aD2tVztleJqad\nNNPXeTykqtwi8+rH4ar8O3KkuDFFR1VJXvgKHV1Iwov9oPIPhM/DQP6RptaP\nzlMOFarao445ZxCIJ+SSObaEIjSN9Vp6J+M7NJIl8nQwdIUsjkOMrizadl6o\njW+dZpSVC53yRQWyYkeIHKeWpIyoAsKdsii9w5t/OxJqbDHOxuPSTWQIjqMn\nC34DXlChZyT0/wFKUUT9wyM7vCEynn+poqtZ1SJpdtHQ1Sva2daPe9Xho/2M\nYs8wuoghqSV5qdUc51W+JeMU+C2XSFLrsGaed89saujqRKpNNH3XWnaGynXX\nK0nIsJ11ERn0JIXOvhrxpVpzj31gH76zITdgC5uUqMYANJKg590Hgu9dp0bN\n/boqJErIJtTNgdo5vhPzEZp2TfI7Eir9oGIDDDOy47MjF9YnLwt4DiXptvxN\nwiuUS43f6wPC7tBQk0RXIpOu9mz3Wuj/YBOshaSADIikHUIYDT0UbLc2Konm\nDw1If9px3rUStszihCsfVEl/3NahMFMPWJ7wW+sF1lEI9P22PoM3hUftBBEC\n2PhE/jYWUe5QSOMBVp912bQr20zMqH1Kyzf09Fj9xqjWvcGEIWzvsGIzH1+Y\nAikcZMb8PeSDcsw3sHzmFXMgeRSD+3H4BToA80wc1lR1k8AC04ZOYuJ+w8ze\nbxAZ\r\n=S42t\r\n-----END PGP SIGNATURE-----\r\n"
            },
            "_npmUser": {
                "name": "braintree",
                "email": "team-sdk@getbraintree.com"
            },
            "directories": {},
            "maintainers": [
                {
                    "name": "braintree",
                    "email": "team-sdk@getbraintree.com"
                }
            ],
            "_npmOperationalInternal": {
                "host": "s3://npm-registry-packages",
                "tmp": "tmp/framebus_5.1.2_1613576161894_0.7053817577949102"
            },
            "_hasShrinkwrap": false
        }
    },
    "readme": "# Framebus [![Build Status](https://github.com/braintree/framebus/workflows/Unit%20Tests/badge.svg)](https://github.com/braintree/framebus/actions?query=workflow%3A%22Unit+Tests%22) [![Build Status](https://github.com/braintree/framebus/workflows/Functional%20Tests/badge.svg)](https://github.com/braintree/framebus/actions?query=workflow%3A%22Functional+Tests%22) [![npm version](https://badge.fury.io/js/framebus.svg)](http://badge.fury.io/js/framebus)\n\nFramebus allows you to easily send messages across frames (and iframes) with a simple bus.\n\nIn one frame:\n\n```js\nvar Framebus = require(\"framebus\");\nvar bus = new Framebus();\n\nbus.emit(\"message\", {\n  from: \"Ron\",\n  contents: \"they named it...San Diago\",\n});\n```\n\nIn another frame:\n\n```js\nvar Framebus = require(\"framebus\");\nvar bus = new Framebus();\n\nbus.on(\"message\", function (data) {\n  console.log(data.from + \" said: \" + data.contents);\n});\n```\n\nThe Framebus class takes a configuration object, where all the params are optional.\n\n```js\ntype FramebusOptions = {\n  origin?: string, // default: \"*\"\n  channel?: string, // no default\n  verifyDomain?: (url: string) => boolean, // no default\n};\n```\n\nThe `origin` sets the framebus instance to only operate on the chosen origin.\n\nThe `channel` namespaces the events called with `on` and `emit` so you can have multiple bus instances on the page and have them only communicate with busses with the same channel value.\n\nIf a `verifyDomain` is passed, then the `on` listener will only fire if the domain of the origin of the post message matches the `location.href` value of page or the function passed for `verifyDomain` returns `true`.\n\n```js\nvar bus = new Framebus({\n  verifyDomain: function (url) {\n    // only return true if the domain of the url matches exactly\n    url.indexOf(\"https://my-domain\") === 0;\n  },\n});\n```\n\n## API\n\n#### `target(options: FramebusOptions): framebus`\n\n**returns**: a chainable instance of framebus that operates on the chosen origin.\n\nThis method is used in conjuction with `emit`, `on`, and `off` to restrict their results to the given origin. By default, an origin of `'*'` is used.\n\n```javascript\nframebus\n  .target({\n    origin: \"https://example.com\",\n  })\n  .on(\"my cool event\", function () {});\n// will ignore all incoming 'my cool event' NOT from 'https://example.com'\n```\n\n| Argument  | Type            | Description                        |\n| --------- | --------------- | ---------------------------------- |\n| `options` | FramebusOptions | See above section for more details |\n\n#### `emit('event', data?, callback?): boolean`\n\n**returns**: `true` if the event was successfully published, `false` otherwise\n\n| Argument         | Type     | Description                                          |\n| ---------------- | -------- | ---------------------------------------------------- |\n| `event`          | String   | The name of the event                                |\n| `data`           | Object   | The data to give to subscribers                      |\n| `callback(data)` | Function | Give subscribers a function for easy, direct replies |\n\n#### `emitAsPromise('event', data?): Promise`\n\n**returns**: A promise that resolves when the emitted event is responded to the first time. It will reject if the event could not be succesfully published.\n\n| Argument | Type   | Description                     |\n| -------- | ------ | ------------------------------- |\n| `event`  | String | The name of the event           |\n| `data`   | Object | The data to give to subscribers |\n\nUsing this method assumes the browser context you are using supports Promises. If it does not, set a polyfill for the Framebus class with `setPromise`\n\n```js\n// or however you want to polyfill the promise\nconst PolyfilledPromise = require(\"promise-polyfill\");\n\nFramebus.setPromise(PolyfilledPromise);\n```\n\n#### `on('event', fn): boolean`\n\n**returns**: `true` if the subscriber was successfully added, `false` otherwise\n\nUnless already bound to a scope, the listener will be executed with `this` set\nto the `MessageEvent` received over postMessage.\n\n| Argument               | Type     | Description                                                 |\n| ---------------------- | -------- | ----------------------------------------------------------- |\n| `event`                | String   | The name of the event                                       |\n| `fn(data?, callback?)` | Function | Event handler. Arguments are from the `emit` invocation     |\n| â†³ `this`               | scope    | The `MessageEvent` object from the underlying `postMessage` |\n\n#### `off('event', fn): boolean`\n\n**returns**: `true` if the subscriber was successfully removed, `false` otherwise\n\n| Argument | Type     | Description                      |\n| -------- | -------- | -------------------------------- |\n| `event`  | String   | The name of the event            |\n| `fn`     | Function | The function that was subscribed |\n\n#### `include(popup): boolean`\n\n**returns**: `true` if the popup was successfully included, `false` otherwise\n\n```javascript\nvar popup = window.open(\"https://example.com\");\n\nframebus.include(popup);\nframebus.emit(\"hello popup and friends!\");\n```\n\n| Argument | Type   | Description                                  |\n| -------- | ------ | -------------------------------------------- |\n| `popup`  | Window | The popup refrence returned by `window.open` |\n\n#### `teardown(): void`\n\nCalls `off` on all listeners used for this bus instance and makes subsequent calls to all methods `noop`.\n\n```javascript\nbus.on(\"event-name\", handler);\n\n// event-name listener is torn down\nbus.teardown();\n\n// these now do nothing\nbus.on(\"event-name\", handler);\nbus.emit(\"event-name\", data);\nbus.off(\"event-name\", handler);\n```\n\n## Pitfalls\n\nThese are some things to keep in mind while using **framebus** to handle your\nevent delegation\n\n### Cross-site scripting (XSS)\n\n**framebus** allows convenient event delegation across iframe borders. By\ndefault it will broadcast events to all iframes on the page, regardless of\norigin. Use the optional `target()` method when you know the exact domain of\nthe iframes you are communicating with. This will protect your event data from\nmalicious domains.\n\n### Data is serialized as JSON\n\n**framebus** operates over `postMessage` using `JSON.parse` and `JSON.stringify`\nto facilitate message data passing. Keep in mind that not all JavaScript objects\nserialize cleanly into and out of JSON, such as `undefined`.\n\n### Asynchronicity\n\nEven when the subscriber and publisher are within the same frame, events go\nthrough `postMessage`. Keep in mind that `postMessage` is an asynchronous\nprotocol and that publication and subscription handling occur on separate\niterations of the [event\nloop (MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/EventLoop#Event_loop).\n\n### Published callback functions are an abstraction\n\nWhen you specify a `callback` while using `emit`, the function is not actually\ngiven to the subscriber. The subscriber receives a one-time-use function that is\ngenerated locally by the subscriber's **framebus**. This one-time-use callback function\nis pre-configured to publish an event back to the event origin's domain using a\n[UUID](http://tools.ietf.org/html/rfc4122) as the event name. The events occur\nas follows:\n\n1. `http://emitter.example.com` publishes an event with a function as the event data\n\n   ```javascript\n   var callback = function (data) {\n     console.log(\"Got back %s as a reply!\", data);\n   };\n\n   framebus.emit(\"Marco!\", callback, \"http://listener.example.com\");\n   ```\n\n1. The **framebus** on `http://emitter.example.com` generates a UUID as an event name\n   and adds the `callback` as a subscriber to this event.\n1. The **framebus** on `http://listener.example.com` sees that a special callback\n   event is in the event payload. A one-time-use function is created locally and\n   given to subscribers of `'Marco!'` as the event data.\n1. The subscriber on `http://listener.example.com` uses the local one-time-use\n   callback function to send data back to the emitter's origin\n\n   ```javascript\n   framebus\n     .target(\"http://emitter.example.com\")\n     .on(\"Marco!\", function (callback) {\n       callback(\"Polo!\");\n     });\n   ```\n\n1. The one-time-use function on `http://listener.example.com` publishes an event\n   as the UUID generated in **step 2** to the origin that emitted the event.\n1. Back on `http://emitter.example.com`, the `callback` is called and\n   unsubscribed from the special UUID event afterward.\n\n## Development and contributing\n\nSee [**CONTRIBUTING.md**](CONTRIBUTING.md)\n",
    "maintainers": [
        {
            "name": "braintree",
            "email": "team-sdk@getbraintree.com"
        }
    ],
    "time": {
        "modified": "2021-02-17T15:36:04.382Z",
        "created": "2015-04-16T18:23:10.251Z",
        "1.0.0": "2015-04-16T18:23:10.251Z",
        "2.0.0": "2015-06-22T22:28:09.734Z",
        "2.0.1": "2015-08-04T19:44:07.040Z",
        "2.0.2": "2015-08-18T23:43:52.844Z",
        "2.0.3": "2015-09-10T20:15:56.394Z",
        "2.0.4": "2015-12-21T18:44:35.946Z",
        "2.0.5": "2016-04-28T21:26:21.785Z",
        "2.0.6": "2016-06-16T16:10:38.262Z",
        "2.0.7": "2016-06-16T17:40:38.429Z",
        "2.0.8": "2017-02-09T16:53:24.589Z",
        "3.0.0": "2018-03-23T21:22:35.577Z",
        "3.0.1": "2018-04-30T15:58:27.295Z",
        "3.0.2": "2018-12-05T19:16:44.474Z",
        "4.0.0": "2020-05-18T20:49:37.766Z",
        "4.0.1": "2020-06-12T12:27:06.163Z",
        "4.0.2": "2020-06-29T20:30:27.398Z",
        "4.0.3": "2020-10-01T15:12:17.608Z",
        "4.0.4": "2020-10-01T15:15:31.995Z",
        "4.0.5": "2020-10-26T18:43:11.924Z",
        "5.0.0-rc.1": "2020-10-31T02:09:37.086Z",
        "5.0.0": "2020-11-02T21:44:53.676Z",
        "5.1.0": "2021-01-27T19:18:37.063Z",
        "5.1.1": "2021-02-17T15:12:39.119Z",
        "5.1.2": "2021-02-17T15:36:02.041Z"
    },
    "homepage": "https://github.com/braintree/framebus",
    "repository": {
        "type": "git",
        "url": "git+ssh://git@github.com/braintree/framebus.git"
    },
    "author": {
        "name": "braintree",
        "email": "code@getbraintree.com"
    },
    "bugs": {
        "url": "https://github.com/braintree/framebus/issues"
    },
    "license": "MIT",
    "readmeFilename": "README.md"
}